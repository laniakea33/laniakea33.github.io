---
layout: posts
title: "[Java] Java 01"
date:  2019-07-22 09:26:55 +0900
categories:
    - Java
---
//	상속, protected
package day06;

//	서브 클래스의 인스턴스가 만들어지는 공간에 슈퍼 클래스의 멤버 변수가 먼저 생성된 후 서브 클래스의 멤버가 만들어 진다

class Upper{
	public int a;
	public void printUpper() {
		System.out.println("어퍼!, " + a);
	}
}

class Lower extends Upper {
	public int b;
	public void printLower() {
		System.out.println("로어!, " + a + ", " + b);
	}
}

//	클래스에서 생성자를 안 만들어놓으면 자동으로 빈 생성자를 만들어 놓는다
//	하위 클래스의 생성자에서 super()를 반드시 호출해줘야 한다. super()는 상위 클래스의 생성자 호출을 의미한다.
//	super()에서 일단 상위 클래스의 생성자를 먼저 실행한후 다시 돌아와 생성자를 마저 실행한다.

class A {	//	부모 클래스, 상위 클래스, super class, base class, 기초 클래스...
	protected int a;
	protected int b;
	
	public A(int a, int b) {
		this.a = a;
		this.b = b;
	}
	
	public int getA() {
		return a;
	}
	public void setA(int a) {
		this.a = a;
	}

	void testA( ) {
		System.out.println("A 클래스 멤버");
	}
}

class B extends A {	//	자식 클래스, 하위 클래스, sub class, derived class, 파생 클래스...
	//	A에서 private으로 지정된 멤버는 B에서 사용할 수 없다
	//	protected 지정자는 클래스 내부, 상속받은 클래스까지 사용범위를 확장시켜 준다
	int x;
	int y;
	
	public B(int a, int b, int x, int y) {
		super(a, b);
		this.x = x;
		this.y = y;
		System.out.println(getA());
	}
	
	void testB() {
		System.out.println("B 클래스 멤버");
	}
}


package day06;

class Person{
	private String name;
	private int age;
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	public void showInfo() {
		System.out.println("이름 : " + name + ", 나이 : " + age);
	}
}

class Student extends Person {
	//	private String name
	//	private int age
	//	public void showInfo()
	
	private int year;
	private int group;
	
	
	
	public Student(String name, int age, int year, int group) {
		super(name, age);
		this.year = year;
		this.group = group;
	}
	
	@Override	//	super class의 showInfo()를 다시 정의한다 
	public void showInfo() {	//	멤버 변수 출력
		super.showInfo();
		System.out.println(year + "학년 " + group + "반");
	}
}

//	하위 클래스 인스턴스를 상위클래스 타입으로 받는것이 가능하다
		//	반대는 불가능 
		//	ex) String을 Object로 받는것은 가능하나 Object를 String으로 형변환할수 없다.
        //	 하위 클래스를 상위 클래스 타입으로 받으면 메소드도 상위 클래스의 메소드만 사용할 수 있다
		//	다만 override된 메소드는 메모리 상에 가장 하단까지 연결되어 있기 때문에
		//	원래 new 키워드 뒤에 붙여줬던 인스턴스 타입의 override함수가 호출되게 된다.
		//	즉 마지막 상황에서 obj2는 사실은 Gamma이지만 Alpha의 연장을 들고 있다고도 할 수 있다.
		//	없는 연장이 필요한 메소드는 실행을 못하지만 있는 연장으로는 자신의 방식으로 메소드를 실행할 수 있다.

        //	Person을 Student가 상속했다.
		//	이 배열에는 Person과 Person을 상속한 클래스를 모두 담을 수 있다
		//	그냥 꺼내서 실행해도 override된 메소드는 알아서 각 객체타입 별로 실행된다.

        //	상위 클래스의 참조변수는 하위 클래스의 인스턴스 저장

		//상속: 코드의 재사용!
//extends 클래스의 멤버를 그대로 재 사용하겠다는 선언
//다형(多形)성 표현
// 오버로딩, 오버라이딩(Overriding)
//부모와 동일한 목적을 가지는 기능인 경우 동일한 이름을 쓰는 것이 유리