---
title: "[Java] Java 01"
categories:
    - Java
---
package day02;

public class Ramda {
	
	//	람다식으로 구현할 인터페이스(추상 메소드는 반드시 하나여야만 하고, 이런 인터페이스 형태를 함수형 인터페이스라고 한다)
	@FunctionalInterface	//	함수형 인터페이스임을 명시하는 어노테이션, 추상 메소드를 추가하면 컴파일 에러를 뿜뿜
	public interface Movable {
		public void move(String str);
	}

	//	일회용 익명 클래스
	static Movable movable = new Movable() {	//	Movable로 선언했기때문에 new Movable구문은 없어도 되지않을까
		@Override
		public void move(String str) {	//	메소드가 하나뿐이니 메소드 안써도 알아먹지 않을까, 그럼 인자도 자동으로 알겠지
			System.out.println("부릉부릉부릉" + str);
		}
	};
	
	//	람다1
	static Movable movable1 = (str) -> {	//	인자가 하나뿐이니 괄호도 없어도 되잖아
		System.out.println("부릉부릉부릉" + str);	//	한문장뿐일때는 중괄호도 버려
	};
	
	//	람다2
	static Movable movable2 = str -> System.out.println("부릉부릉부릉" + str);
	
	static Movable movable3 = new Movable() {
						//	Stateless Object 개념
						//	익명 객체 속에 만들어준 그 인스턴스만의 변수
		int speed = 0;	//	이걸 인스턴스 필드라고 함
						//	람다식으로 인터페이스를 구현하면 객체는 인스턴스 필드를 가질수 없다
						//	메소드는 객체의 상태에 따라 인풋이 달라지지 않아도 아웃풋이 달라질수가 있다
						//	함수형 프로그래밍에서는 이를 방지하기 위해 람다식에서 인스턴스 필드를 만들 수 없다
		//	참고 : 함수 vs 메소드
		//	함수 : 오직 input에 의해서만 output이 결정됨
		//	메소드 : 반드시 객체에 종속되어 있으며 객체의 상태에 따라 input이 같아도 output이 달라질 수 있다

		@Override
		public void move(String str) {
			System.out.println("부릉부릉부릉" + str);
		}
	};
	
	// 재사용 가능 클래스
	class Car implements Movable {
		@Override
		public void move(String str) {
			System.out.println("부릉부릉" + str);
		}
	}
	
	public static void main(String[] args) {
		movable.move("ㅎㅇ");
	}
	
}
