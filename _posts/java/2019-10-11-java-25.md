---
title: "[Java] HashMap"
categories:
    - Java
---
※이 포스트는 https://d2.naver.com/helloworld/831311를 참고해 작성하였습니다.

★Hash 함수 : 가변적인 길이의 데이터를 고정 길이의 데이터로 변환하는 함수이다. y = hash(x)에서 y의 길이는 고정되어 있다. 

★Hash 함수는 결과값 y를 이용해 x를 역추적하는 것이 불가능하다는 특성(일방향성)과 입력값이 다르면 항상 출력값도 다르다는 특성(충돌회피성)을 갖고, 이로 인해 무결성이 생겨난다. 이러한 특성은 수 많은 데이터가 연결되어 있는 블록체인과 같은 분야에서 중요한 역할을 한다.

★HashMap은 Key, Value쌍을 입력 받아 Hash함수를 이용해 데이터의 Key를 고정길이의 데이터로 변환하여 나온 결과값을 index로 사용해 해당 위치에 Value를 저장한다.

★Perfect Hash Functions(완전 해시 함수) : X.equals(Y)가 false일 때 X.hashCode() == Y.hashCode()가 항상 false이면 이 해시함수 완전 해시 함수라고 한다. 

★하지만 기본자료형의 경우는 데이터 그 자체를 hashCode값으로 사용할 수 있기 때문에 완전 해시 함수를 사용할 수 있으나 다른 객체 자료형의 경우에 완전한 해시함수를 제작하는 것은 사실상 불가능 하다. 데이터x의 수는 무한대에 수렴하나 결과 hashCode인 y값은 유한하기 때문에 비둘기집 원리에 의해 반드시 중복이 발생할 수 밖에 없게 된다.

★HashMap은 기본적으로 각 객체의 hashCode()가 반환하는 값을 사용하는데 이 반환값은 2^32크기의 정수형이다. 그러나 생성 가능한 객체의 수가 2^32보다 많을 수 있고, 모든 Map이 2^32크기를 가져야 한다는 점에서 반환값의 범위를 2^32보다 작은 값 M을 사용한다. 즉 실제 사용되는 index값은 x.hashCode() % M이 된다.

★이러한 사용방식은 객체에서의 해시함수 불완전성에 더해 해시코드의 범위를 좁힘으로써 해시 충돌의 가능성을 더 높여 준다. 따라서 이렇게 해시 충돌이 발생한 경우에도 HashMap을 잘 작동시키기 위해서 대표적으로 두가지 방식을 사용한다

1. Open Addressing : 데이터를 사용하려는 해시 버킷이 이미 사용중인 경우 다른 버킷에 데이터를 저장하는 방법이다. 
2. Separate Chaning : 데이터를 사용하려는 해시 버킷이 이미 사용중인 경우, 데이터를 Linked List로 연결하여 저장하는 방법이다. 검색 속도를 향상시키기 위해 JDK8에서는 충돌한 데이터의 수가 8개 이상이 되면 Linked List 대신 Tree로 변경하고, 다시 6개로 줄어들면 Linked List로 변경한다. 여기서 Tree는 Red-Black Tree를 적용시켰다.

★일반적으로 Open Addressing 방법은 데이터의 수가 늘어날수록 해시충돌 확률이 더 높아지기 때문에 데이터의 수가 일정 이상인 경우 Separate Chaning방식보다 느리기 때문에 자바에서는 Separete Chaning방식을 채용하고 있다.

★String의 hashCode()에서는 문자의 갯수만큼 기존의 해시값에 31을 곱한 후 각 문자의 코드를 넣고 다시 31을 곱하는 작업을 반복한다. 31은 소수이며 시프트 연산으로 곱셈을 빠르게 할 수 있기 때문이다.

★HashTable과 HashMap : HashTable은 JDK1에서, HashMap은 JDK2에서 등장한 API이다. 둘다 Map을 구현하고 있으나 HashTable과 달리 HashMap은 보조 해시 함수를 사용하고, 성능 또한 지속적으로 개선되고 있으나 HashTable은 거의 변화가 없다. 사실상 저버전 JRE를 대상으로 한 호환성을 위해 유지만 되고 있는 것으로 보인다.

★결국 HashMap도 내부적으로 배열을 사용하므로 탐색 시간은 O(1)로 굉장히 빠른 편이다. 