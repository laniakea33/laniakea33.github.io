---
title: "[Algorithm] Red Black Tree"
categories:
    - Algorithm
---
★Red Black Tree란 이진 탐색 트리의 치우침 문제(?)를 해결하기 위한 이진 탐색 트리이다. 레드 블랙 트리는 균형이 잡혀있는데, 여기서 균형이 잡혀있다는 말은 자료가 한쪽으로 쏠리지 않도록 어느 깊이의 노드가 꽉 찰 때까지 다음 깊이로 내려가지 않는다는 의미이다. 그래서 치우침이 없고, 탐색 연산의 시간 복잡도는 O(log n)임이 유지된다.

★Red Black Tree의 조건
1. 루트 노드의 색은 Black.
2. 모든 External 노드는 Black.
3. Red 노드의 자식은 Black이고, Red 노드가 연속으로 나올 수 없다(No Double Red).
4. 모든 리프 노드의 Black Depth는 같다. 즉 루트에서 리프까지의 경로에서 Black 노드의 수는 같다.

★root를 제외한 새로 추가되는 노드들은 모두 Red 노드이다. 때문에 자료를 넣다보면 Red가 연속으로 올 수 없다는 3번 조건을 반드시 위반하게 된다(Double Red).

★Double Red를 해결하기 위해 조건에 따라 두 가지 전략을 사용한다.
1. 현재 삽입된 노드의 삼촌 노드(부모의 형제 노드)가 Black일 때 : Restructuring
2. 삼촌 노드가 Red일 때 : Recoloring

★Restructuring : 지금 들어온 노드, 그 노드의 부모노드, 조부모노드를 오름차순으로 정렬한다. 중간값을 부모로, 나머지 둘을 자식으로 하는 서브 트리를 만든다. 그 서브트리의 루트를 Black으로, 나머지 두 자식을 Red로 한다. 그리고 삼촌 노드를 서브트리에 삽입한다. 이 연산은 다른 서브트리에 영향을 주지 않으며, 연산 전후의 Black Depth의 변화가 없고, 한번의 수행으로 끝난다. Restructuring의 시간복잡도는 O(1)이지만, 기본적으로 삽입연산 후에 일어나므로 O(log n)가 총 수행시간이다.

★Recoloring : 지금 삽입된 노드의 부모와 삼촌노드를 Black으로, 조부모를 Red로 한다. 조부모가 루트 노드가 아니면 Double Red가 다시 발생할 수 있다(루트 노드일 경우는 1번 조건에 위배되지 않으므로 문제 없음). Double Red가 발생한다면 그 지점에서 다시 Uncle Node를 확인해 Restructuring이나 Recoloring을 수행한다. 연산의 시간 복잡도 자체에는 (1)이 걸린다. 그러나 최악의 경우 Root로 갈때까지 계속 발생할 수 있으므로 O(log n)의 시간이 걸린다. 삽입시간까지 합쳐 총 O(log n)의 시간 복잡도를 갖는다.

★결국 삽입하는 경우에 O(log n)이라는 결론이 나온다.

★4번 조건에 의해 리프에서 루트까지 Black Depth는 일치해야 한다. 따라서 가장 짧은 경로를 가진 노드나 가장 긴 경로를 가진 노드의 Black Depth는 일치한다. 가장 짧은 경로의 경우는 결국 Black Node만으로 구성된 경로이고, 가장 긴 경로는 모든 Black Node의 사이사이에 Red Node가 하나씩 있는 경우인데, 둘의 차이는 길어도 2배가 채 안된다. 그래서 이진 탐색 트리보다 훨씬 균형잡힌 트리가 되는 것이다.

★이 Red Black Tree로 TreeSet을 직접 구현해 보자.