---
title: "RxJava"
categories:
    - Android
---
★Rx의 4가지 개념 : Observable, Observer, Subscriber, Subject
            
* 발행자와 수신자 분류
    1. 발행자 : Observable, Single, Maybe, Subject, Completable
    2. 수신자 : Subscriber, Observer, Consumer. 이 개념들은 혼용된다.
        
* Observable
    * Observable : Observer패턴을 구현한다. 객체의 상태 변화를 관찰하는 옵저버객체의 목록을 갖고 있다가 
        상태 변화가 발생하면 전달한다. onNext(), onComplete(), onError() 등 3종류의 알림이 있다.
        Observable 클래스는 직접 생성자를 사용하여 인스턴스를 만들지 않고, 
        팩토리 함수를 사용한다. create(), just(), from(), fromArray(), fromIterable(), fromCallable(),
        fromFuture(), fromPublisher(), interval(), range(), defer().
        * just() : 인자로 넣은 이미 존재하는 단일 데이터를 발행한다. 최대 10개까지 인자로 넣을 수 있다.
        * subscribe() : Observable은 팩토리 함수로 데이터의 흐름을 정의한 후 subscribe()를 호출해야만 비로소
            데이터 발행을 실행한다. 즉 데이터 발행 시점을 조절할 수 있다.
            * 인자의 갯수에 따라 onNext, onComplete, onError중 어떤 알림을 받을 지 정한다.
            * Disposable 인터페이스 객체를 리턴한다. 이 객체는 Observable이 더 이상 데이터를 발행하지 않도록
                구독을 해지하는데 사용한다(dispose()). 
        * 실행 알고리즘을 명시하지 않고 무엇을 실행할 것인지 만을 명시한다는 점에서 RxJava는
            선언형 프로그래밍을 지향한다고 한다.
        * create() : just와 다르게 직접 onNext()를 호출해 줘야 한다. 마지막에는 onComplete()를 호출
            create()의 인자에는 ObservableEmitter를 넣는다.
        * 람다 표현식의 장점 : 람다를 사용하지 않으면 subscribe(Consumer<T>)함수의 원형을 알아야 하고,
            Consumer<T>클래스의 메소드도 매번 입력해줘야 하며 T의 타입을 일일이 맞추는 것도 까다롭다.
            람다 표현식은 메소드의 원형을 지키지 않아도 되어 가독성이 높고, 개발자가 모두 기억할 필요도 없다.
        * fromArray() : 배열에 있는 데이터를 발행, 기본자료형 배열은 박싱클래스의 배열로 변환 후 사용.
        * fromIterable() : Iterator 인터페이스의 데이터를 발행.
        * fromCallable() : callable 인터페이스의 call메소드 실행결과를 발행.
        * fromFuture() : Future객체의 실행 결과를 발행.
            (Executor 인터페이스를 구현한 클래스에 Callable객체를 인자로 넣어 Future객체를 반환하게 함.
                get()을 호출하면 Callable 객체에서 구현한 결과가 나올 때 까지 블로킹 됨.)
        * fromPublisher() : Publisher가 발행하는 데이터를 발행.
        
    * Single : 딱 하나의 데이터를 발행하기 위함. API통신에 주로 사용. onNext()와 onComplete()가 onSuccess()로
        통합. Single.fromObservable(), Observable.single() 등으로 얻을 수 있음.
        
    * Maybe : Single인데 데이터가 있을수도, 없을 수도 있음. Single 클래스에 onComplete()가 추가. 
        
    * Hot Observable : 아이템이 생성되면 바로 발행. 옵저버는 시퀀스의 중간쯤 부터 옵저빙.
        구독자 존재여부에 관계없이 데이터를 발행. 키보드, 마우스, 시스템이벤트, 센서 데이터, 주식 가격 등이 있음.
    * Cold Observable : 옵저버가 옵저빙할 준비가 되면 발행을 시작함. 옵저버는 처음부터 옵저빙이 보장 됨.
        쉽게말해 subscribe()를 호출하지 않으면 데이터발행을 시작하지 않음.
        
* Subject : Observable이면서 구독자. Cold를 Hot으로 바꿔준다.
    새로운 아이템을 발행하거나 옵저빙한 아이템을 바이패스 할 수도 있음.
            1. PublishSubject : 일반적인 Subject. subscribe()를 통해 구독을 준비함.
                아이템의 발행 타이밍은 중요하지 않으며 발행했을 때의 상황만 고려하면 됨. 
                create()로 생성
            2. BehaviorSubject : 가장 최근에 관찰된 아이템과 그 이후의 아이템을 옵저버에게 발행.
                createDefault()로 초기값과 함께 생성 
            3. ReplaySubject : 모든 아이템을 버퍼에 저장해 두고 옵저버에게 발행함
            4. AsyncSubject : 발행이 완료되었을 때 마지막 값만을 옵저버에게 발행.
                create()로 생성

* ConnectableObservable : publish()로 생성. subscribe() 호출 이후 connect()를 호출해야
    구독자들에게 데이터를 발행하기 시작한다. connect()이후 subscribe()를 호출한 구독자는 이후부터 발행된
    데이터를 전달받음.
    
* Schedulers : 세부작업 관리자 개념. 어떤 동작을 실행할 스레드를 지정할 수 있게 해줌.
    * subscribeOn() : subscribe()를 호출해 구독하는 스레드를 지정. 처음 지정한 스레드가 고정됨.
    * observeOn() : 데이터 흐름이 처리될 때 동작이 일어날 스레드를 지정. 체이닝 단계에 따라 변경 가능.
    * 예를 들어 Observable.create {...}에서 일어나는 일은 subscribeOn()에 지정된 스레드에서,
        subscribe{...}에서 일어나는 일은 observeOn()에 지정된 스레드에서 실행된다.
    
    * 종류(Schedulers)
        1. newThread() : 새 스레드
        2. single() : 싱글 스레드하나를 생성하여 돌려씀.
        3. computation() : 입출력없는 계산용. 스레드풀의 스레드 갯수는 프로세서 갯수와 동일.
        4. io() : IO. 필요할 때마다 스레드를 계속 생성.
        5. trampoline() : 트램펄린. 새 스레드 생성없이 현재 스레드에 이벤트 큐를 생성.
        6. executer를 변환하여 사용 : Schedulers.from(...). 기존의 Executer와의 호환용.
        
* 

* Flowable : 